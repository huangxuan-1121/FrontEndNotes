# 网络

[TOC]

## OSI网络分层（7层）

OSI：开发系统互联

- 应用层：负责对软件提供接口，使之能使用网络服务
- 表示层：把数据转换成合适、可理解的语法语义
- 会话层：维护网络中的连接状态，即保持会话和同步，有SSL
- 传输层：提供端到端的服务，端到端之间的通信，提供应用程序进程间的数据传输服务
- 网络层：主要解决路由选择、拥塞控制和网络互联等问题
- 数据链路层：负责数据帧的传输
- 物理层：负责比特流在节点间的传输

## TCP和UDP

1. #### TCP（传输控制协议）

   - 面向字节流
   - 面向连接
   - 提供可靠交付的服务
   - 提供全双工通信
   - 每个tcp连接只能是点对点的（一对一）

2. #### UDP（用户数据报协议）

   - 面向`报文`
   - 无连接、不可靠
   - 尽最大努力交付
   - 无拥塞控制
   - 提供多对多、一对多、多对一、一对一的交互通信
   - 首部开销小

### TCP连接过程（三次握手）

起初，两端都是CLOSED状态。在通信开始之前，两端都会创建TCB（传输控制块）。服务器创建完TCB后便进入LISTEN状态，此时等待客户端发送数据。

第一次握手：A->B

​	客户端向服务器发送请求连接报文，其中包含自身通信数据的初始序列号，即SYN=1，seq=x;发生后客户端进入SYN-SENT状态。

第二次握手：B->A

​	服务器端收到客户端发来的请求报文后，如果同意连接，则服务器端回复一个确认报文，之后便进入SYN-RECEIVED状态。

第三次握手：B->A

​	客户端收到服务器端发来的同意连接应答后，还要向服务器端回复一个确认报文。客户端发送完这个报文后便进入ESTABLISHED状态，服务器端收到报文后也加入ESTABLISHED状态；此时连接建立成功！

##### 为什么需要三次握手，两次不可以吗？

为了防止失效的连接请求报文被服务器端接收的情况，从而产生错误。

客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求B。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。    
假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 **ESTABLISHED** 状态。但是客户端其实是 **CLOSED** 的状态，那么就会导致服务端一直等待，造成资源的浪费。

### TCP释放连接过程(四次挥手)

因为TCP是全双工的，所以在断开连接时，两端都需要发送FIN和ACK。

第一次挥手：A->B

客户端的发送带有FIN标志的包，请求断开连接（连接释放）。

第二次挥手：B->A

服务器端收到客户端发来的请求释放连接后，会告诉应用层要释放连接并回复一个确认包，进入状态CLOSE_WIAT状态。此时表明客户端A->服务器B的连接已经释放了，不再接受A发送的数据，但是因为TCP连接时全双工的，所以B还可以发送数据给A.

第三次挥手：B->A

服务器端如果还有数据需要发送，则继续发送。完毕后会向客户端发送连接释放请求，此时服务器端会进入LAST_ACK状态。

第四次挥手：A->B

客户端收到释放连接后，会向服务器端发送确认应答，此时客户端进入TIME_WAIT状态。该状态会持续2MSL（最大段生存期）时间，若该时间段服务器端没有重发请求的话，就进入CLOSED状态。当服务器端收到确认应答后，也便进入CLOSED状态。

##### 为什么要等待2MSL的时间，客户端才进入CLOSED状态?

为了保证服务器端能收到客户端的确认应答。如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接.

## HTTP

建立在TCP上的应用层协议,超文本传输.

特点:

- 无状态
- 基于请求和响应
- 使用明文通信、请求和响应不会对通信方进行确认（验证）、无法保证数据的**完整性**。

### 各版本特点:

http1.0:客户端发送的每次请求都需要服务器回送响应,在请求结束后,会主动释放连接.

http1.1:在一次连接中可以有多个请求,并且多个请求可以重叠进行,不需要等待一个请求结束后就可以发送请求.

http2.0:支持多路复用,头部还进行了压缩;一次TCP连接中可以同时传输多个请求.

http3.0:使用了QUIC协议(为了解决丢包),在出现丢包的情况下,只有丢包的TCP等待重传,剩余的TCP连接可以继续传输.

> QUIC协议:
>
> 基于UDP，并在原来的基础上结合了TCP和HTTP，使之可靠．
>
> QUIC特性：多路复用  、 纠错机制  、 0-RTT（RTT：往返时间）
>
> 

### **方法（Method）**

- get：请求一个指定资源的表示形式，用于获取数据
- post：用于将实体提交到指定的资源
- put：用于请求有效载荷替换目标资源的所有当前表示
- delete：删除指定资源
- trace：沿着指定目标资源进行环回测试
- option：描述目标资源的通信选项
- head：请求一个与get请求的响应相同的响应，但是没有响应体
- connect：建立一个到由目标资源标识的服务器隧道
- patch：对资源应用进行部分修改

#### get和post有什么区别？

- get回退（刷新）无害，post回退会被再次提交
- 书签：get可被收藏为书签，post不可以
- 缓存：get能被缓存，post不可以
- post支持的编码类型更多
- 数据类型：get只支持ASCII字符，post没有限制
- 安全性：get的安全性较差，因为发送的数据是url的一部分      
- 历史：get的参数会保存在历史中，post不会。

### **有关HTTP缓存的字段说一下?**

常见的HTTP缓存首部字段有:

- Expires：响应头，代表资源过期的时间
- Cache-Control：请求/响应头，缓存控制字段，精确控制缓存时间
- If-Modified-Since：请求头，资源最近修改时间，由浏览器告诉服务器
- Last-Modified：响应头，资源最近修改时间，由服务器告诉浏览器
- Etag：响应头，资源标识，由服务器告诉浏览器
- If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器

其中，强缓存有：

- Expires（HTTP/1.0）
- Cache-Control（HTTP/1.1）
- 其中 Cache-Control 优先级⽐ Expires ⾼

协商缓存： 

- Last-Modified 和 If-Modified-Since（HTTP/1.0） 
- ETag 和 If-None-Match（HTTP/1.1）

#### **缓存过程：**

- 浏览器每次发送请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
- 浏览器每次从服务器端拿到返回结果，都会将结果和缓存标识存入浏览器缓存中

##### 1、**强缓存：** 

向浏览器缓存查找该结果，并根据该结果的缓存规则来决定是否要使用该缓存的过程。（表示在缓存期间是否要使用缓存，缓存是否有效，需不需要重新发送HTTP请求）

**Expires（HTTP1.0）：**值为服务器返回该请求结果缓存的到期时间:

```
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 并且 Expires 受限于客户端时间，如果修改了客户端时间，可能会造成缓存失效。

**Cache-Control(HTTP/1.1):**

```
Cache-Control:max-age=30
```

该属性值表示资源会在30s后过期，需要再次请求。也就是说在30s内如果再次发送请求，则会直接使用强缓存，强缓存生效。

除了`max-age`,还有其他取值

- public：表示响应可以被客户端和代理服务器缓存
- private：表示响应只可以被客户端缓存
- max-age=30：表示资源会在30s后过期
- s-maxage=30：覆盖max-age，作用一样，但是只在代理服务器中生效
- no-store：不缓存任何响应
- no-cache：资源被缓存，但是立即生效，下次会发起请求验证资源是否过期
- max-stale=30：30s内，即使缓存过期，也使用缓存
- min-fresh：希望在30s内获取最新的缓存

注意下⾯的 `no-cache `，资源依然会被缓存，并且这个缓存要服务器**验证**后才可以使⽤。

问：max-age=0和no-cache等价吗？

从规范的字⾯意思来说，max-age 到期是 应该重新验证，⽽ no-cache 是 必须重新验证。但实际情况以浏览器实现为准，⼤部分情况他们俩的⾏为还是⼀致的。（如果是 maxage=0, must-revalidate 就和 no-cache 等价了）

##### 2、**协商缓存（缓存校验）：** 

强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识决定是否使用缓存的过程。

缓存过期的情况：

- 没有Cache-Control和Expires
- Cache-Control和Expires过期
- 设置了no-cache

需要发起验证服务器资源是否有更新：

- 有，返回200，更新缓存
- 无，返回304，更新浏览器缓存有效期

**Last-Modified 和 If-Modified-Since（HTTP/1.0）**



**ETag 和 If-None-Match（HTTP/1.1）**

### HTTP常见的响应码

RFC 把状态码分成五类，分别是：

-  **1××：** 请求已被接受正被处理，表示⽬前是协议处理的中间状态，还需要后续的操作 
- **2××：** 请求成功处理，报⽂已经收到并被正确处理 
- **3××：** 代表需要客户端采取进⼀步的操作才能完成请求，例如重定向，通常，这些状态码⽤来重 定向，后续的请求地址（重定向⽬标）在本次响应的Location域中指明 
- **4××：** 客户端错误，请求报⽂有误，服务器⽆法处理 
- **5××：** 服务器错误，服务器在处理请求时内部发⽣了错误

##### 1XX: 通知

**100 Continue** 客户端应重新发请求

**101 Switching Protocols** 改用协议 http换到https或者http1.1换到2.0之类

##### 2XX：成功

**200 OK** 操作成功

**201 Created**按照客户端请求创建了一个新资源

**202 Accepted** 请求无法或不被实时处理

**204 No Content** 请求成功，但是报文不含实体的主体部分

- **No Content可能的情况：**
  1.服务器拒绝请求返回
  2.Get资源存在但表示是空的

**205 Reset Content** 请求成功，但是报文不含实体主体部分，要求客户端重置内容

- 204和205的区别在于205要求了重置

**206 Partial Content** 进行范围请求

##### 3XX：重定向

**301 Moved Permanently**永久性重定向，资源已经被分配到了新的URL

**302 Found** 临时重定向，资源临时分配了URL 实际上发部分客户端把它当成303处理

**303 See Other** 表示资源存在另一个URL。应用Get获取资源

**307 Temporary Redirect** 临时重定向，资源临时分配了URL，但是希望客户端能够保持方法不变请求新地址（解决302被当成303处理的问题）

**304 Not Modified** 允许访问资源，但实体主体为空（客户端已经有此数据，不需要再次发送）

##### 4XX：客户端错误

**400 Bad Request** 请求报文语法错误

**401 Unauthorized** 发送的请求需要通过验证，客户端试图对一个受保护的资源操作但没有认证证书

**403 Forbidden** 请求资源存在但被拒绝，常用于一个资源只允许在特定时间段内访问（如果不想透露可以谎报404）

**404 Not Found **找不到请求的资源

**405 Method Not Allowed** 不支持的请求方法，比如只支持Get，但是收到了Post请求

##### 5XX：服务端错误

**500 Internal Server Error** 执行请求时发生错误（处理异常）

**501 Not Implemented** 不支持此请求方法（和405区别在于，405是访问的资源不支持，而501表示服务器不能操作此方法）

**502 Bad Gateway** 代理与上行服务器之间出现问题

**503 Service Unavailable** 服务器暂时处于超负荷或者维护中

问:301、302 和 307区别（对 SEO 的影响）

- 301：可通知搜索引擎蜘蛛，表示某个⽹⻚或⽹站已被永久移动到新位置 
- 302：搜索引擎蜘蛛会继续抓取原有位置并将其编⼊索引，因此某个⻚⾯或⽹站已被移动时，不 要使⽤此代码来通知搜索引擎蜘蛛。 
- 307：临时重定向，307 的定义实际上和 302 是⼀致的，唯⼀的区别在于，307 状态码不允许浏 览器将原本为 POST 的请求重定向到 GET 请求上。

问:401 和 404 的区别

- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 
- 403 forbidden，表示对请求资源的访问被服务器拒绝 打个⽣动的⽐⽅： 
- 401：我去找个⼈，⻔卫说不认识我不让我进
- 403：我去找个⼈，⻔卫说认识我，但是我不能进，因为我不配

### **HTTP 中的 keep-alive 有了解吗？它和多路复⽤的区别**

在http0.9和早期http1.0中，总是频繁的创建、断开连接，极大的消耗性能。

所以在http1.0引入了keep-alive长连接，HTTP1.0中是默认关闭的，可以通过`Connection：keep-alive`打开；但是在HTTP1.1是默认开启的。

**keep-alive：**所谓长连接就是在建立HTTP连接后，即使请求结束了，也不会断开连接，而是会保持一段时间（timeout)。在这段时间内，同一客户端向服务器发送请求都可以复用改TCP连接。省略了反复创建和销毁 TCP 连接的损耗。

**HTTP/2 多路复用：** 

HTTP/1.x虽然引入了keep-alive长连接，但它每次请求都必须等待上一次响应之后才能发起。

原理：首先它引入了帧和流，因为HTTP/1.x是基于文本的，因为是文本就导致它传输时必须是整体。所以，它在传输时就可以将信息分解为独立的帧，交错发送，然后在另一端通过帧中的标识重新组装，这就是多路复用。

**区别：**

- HTTP/1.x是基于文本的，只能传输整体；HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送。
- HTTP/1.x keep-alive必须按照请求顺序返回响应，HTTP/2 多路复用不用按序响应
- HTTP/1.x keep-alive单个TCP连接在同一时刻只能处理一个请求；HTTP/2 单个TCP同一时刻可以发送多个请求

### **HTTP header怎么判断协议是不是websocket？**

答：通过判断header中是否含有`Connection:Upgrade` 和 '`Upgrade:websocket `来判断当前协议是否要升级到websocket。

### **session 和 cookie 的区别**

HTTP是无状态协议，对于事物处理没有记忆能力，每次客户端和服务器会话完成时，服务器不会保存任何会话信息。并且每个请求都是完全独立的，服务器端无法确认当前访问者的身份信息，无法分辨上一次发送者和这一次发送者是不是同一个人。所以服务器和浏览器为了进行会话跟踪（即知道谁在访问我），就必须去维护一个状态，这个状态去告知服务器前后两个请求是否来自同一浏览器。而这个状态需要session和cookie取实现。

#### cookie

- cookie存储在客户端

  cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再次发起请求时被携带并发送到服务器上。

- cookie不可跨越

  每个 cookie 都会绑定单⼀的域名，⽆法在别的域名下获取使⽤，⼀级 域名和⼆级域名之间是允许共享使⽤的（靠的是 domain）。

cookie重要的属性：

![image-20210603181243778](C:\Users\hx\AppData\Roaming\Typora\typora-user-images\image-20210603181243778.png)

#### session

- session是另一种记录服务器和客户端会话状态的机制
- session是基于cookie实现的，session存储在服务器，sessionID存储在客户端的cookie中

![image-20210603181739006](C:\Users\hx\AppData\Roaming\Typora\typora-user-images\image-20210603181739006.png)

- session的认证流程：
  1. 用户第一次请求服务器的时候，服务器根据用户提交的信息，创建对应的session
  2. 请求返回时将对此session的唯一标识sessionID返回给浏览器
  3. 浏览器接收到服务器返回的sessionID后，会将此信息存储cookie中，同时cookie会记录此sessionID属于哪个域名
  4. 当⽤户第⼆次访问服务器的时候，请求会⾃动判断此域名下是否存在 Cookie 信息，如果存在⾃动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明⽤户没有登录或者登录失效，如果找到 Session 证明⽤户已经登录可执⾏后⾯操作。
  
  根据以上流程可知，**SessionID 是连接 Cookie 和 Session 的⼀道桥梁**，⼤部分系统也是根据此原理 来验证⽤户登录状态。

#### session和cookie的区别

- 安全性：session比cookie安全，session是保存在服务器端的，cookie是存储在客户端的
- 存取值的类型不同：cookie只支持存字符串类型数据，先要设置其他类型的数据，要先转换成字符串类型；session可以存储任意类型的数值
- 有效期不同：cookie可以设置长时间保存，session一般失效时间较短，客户端关闭（默认情况下）或session超时（一般30分钟无操作）都会失效。
- 存储大小不同：单个cookie保存的数据不超过4K，session课存储数据远高于cookie，但是但访问量过多，会导致服务器资源占用过多。

### **为什么说HTTPS⽐HTTP安全呢？**

#### HTTP中间人攻击

HTTP协议使用起来非常方便，但是它有一个致命的缺点就是:不安全

HTTP协议中的报文都是明文传输的，不进行任何加密操作，这样会导致中间人攻击，篡改内容。

**如何防止中间人攻击？**

对称加密：加密和解密使用同一个密钥，是对称的；

非对称加密：也称公钥加密算法，有两个密钥，公钥和私钥；公钥用于 加密，私钥用于解密。

#### HTTP和HTTPS的区别：

- HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的TLS（SSL）加密传输协议
- HTTP和HTTPS使用的是完全不同的连接，用的端口也不一样，HTTP的端口是80，后者是443
- HTTP的连接很简单,是无状态的;HTTPS协议是由HTTP+SSL/TLS协议构建的可进行加密传输、身份验证的网络协议，比HTTP协议安全

#### SSL/TSL

SSL(安全套接层)，在OSI模型中处于第五层（会话层），SSL发展到v3时改名为TSL（传输层安全），正式标准化

在TLS中使用两种加密技术，分别是：对称加密和非对称加密，内容传输的加密使用的时对称加密，非对称加密用于验证。
