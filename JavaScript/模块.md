## 模块

模块的工作思想：逻辑方块、各自封装、相互独立。

### 模块依赖、加载、入口

模块依赖：是模块系统的核心，模块系统基于模块依赖来对模块进行加载。

模块加载：在浏览器中，模块加载必须在模块依赖结束之后才能执行。当浏览器没有收到依赖模块的代码时会先请求并等待，收到后再确定刚收到的模块是否也有依赖，然后递归加载所有依赖，直到所有依赖都加载完成才开始执行入口模块。

入口：相互依赖的模块必须需要一个入口作为代码加载的起点。

### CommonJS

CommonJS规范概述了同步声明依赖的模块定义，主要用于服务器端，不能直接在浏览器中直接运行。

Node.js中的模块系统常使用轻微修改版的CommonJS，因为node.js主要在服务器端运行，不需要考虑网络延迟问题。

### AMD

异步模块定义（AMD），以浏览器为目标执行环境，需要考虑网络延迟。策略：让模块声明自己的依赖，在运行时自动按需获取依赖，并在依赖加载完后立即执行依赖它们的模块。

AMD模块用函数进行包装模块定义，使用defined的参数是所要包装模块的函数，

```js
defined(function(request,exports,module){
    
})
```

### UMD

通用模块（UMD），为了解决CommonJS和AMD不能通用的问题，UMD可用于创建这两个系统都可以使用的模块代码。

本质上UMD模块会在启动时检测要使用哪种模块系统，然后进行适当配置，把所有逻辑包装在一个立即执行函数中。

### ES6模块

为解决CommonJS和AMD的冲突，ES6引入了一个大的模块规范系统。

#### 模块的定义、加载、行为

```js
<script type="module">
    //Module Code
</script>
//
<script type="module" src="path" ></script>
```

模块的行为：借用很多CommonJS和AMD的优秀特性，如

- 模块代码只在加载之后执行且只加载一次
- 模块是单例
- 可以定义公共接口，模块之间在公共接口进行交互
- 支持循环依赖
- 模块之间可以相互请求加载其他模块

ES6也定义了新的行为：

- 默认在严格模式下运行
- 不共享全局命名空间
- 模块中的var声明不会添加到window对象
- 使用异步加载和执行
- 模块中顶级this 的值是undefined

#### 模块导出

ES6的模块导入支持：**命名导入**和**默认导入**

命名导入：使用 **export** 关键字用于声明一个值为命名导入，且必须位于模块顶级，不能嵌套

```js
export  ...
```

默认导入：使用 **default** 关键字将一个值声明为默认导入，且一个模块只能有一个默认导入。

```js
const foo = 'foo';
export default foo;
```

#### 模块导入

使用 **import**关键字对模块进行导入